\chapter{Case study}

\section{Cruise control}
We used as a preliminary test of the architecture the \textit{cruise control} problem.
Such problem, even if it does not fully exploit the capabilities of our architecture, was selected since it is one of the classic baseline problem used as CPS.
The problem is more than half-century old and has been solved mechanically \cite{teetor1948mech_cc} at first and, finally, electronically \cite{wisner1971elect_cc} around the '70s.

The aim is very simple: to keep a vehicle running at constant velocity regardless of the \textit{steepness} of the road.
The model used, due to the nature of the problem, does not present a \textit{reactive environment} and, therefore, it does not fully exploit the potential of the our method.
The \textit{environment} of this setting is the road and its steepness that, once defined, cannot vary.

\textit{Cruise control} systems make use of specific \textit{sensors} to measure the current car velocity and one \textit{actuator}, able to vary the engine fuel intake of the engine according to the \textit{controller} decision.

\subsection{Model}
The model $\mathcal{M}$ in such scenario is composed of the \textit{agent} $\alpha$, represented by the car $c$, and the \textit{environment} $\beta$, represented by the road.

The road $r$ is static: in fact, once generated by the \textit{attacker} NN, it remains the same for entire \textit{episode}.
It is generated as a function that represents its elevation profile.
In this specific setting, we generate the road on the physical space $x$ using the \textbf{Radial Basis Function} with a \textit{Gaussian} kernel.

Let $d$ be the number of \textit{RBFs} that we want to sum to generate $r$, let $\pmb{\mu}$ be an arbitrary vector of dimension $d$ that represents the centers of the \textit{RBFs}, let $\pmb{\sigma}$ be the vector of dimension $d$ that represents scale factor of the \textit{RBFs},
let $\pmb{\omega}$ be the vector of dimension $d$ that weights the contribution of each RBF.
The function used to describe the road is:
$$ r(x) = \sum_i^d \omega_i \; \exp \left(- \frac{\lvert\lvert x - \mu_i \rvert\rvert^2}{\sigma_i^2}\right) $$
The vector $\textbf{u}_\beta$ generated by the \textit{attacker} is built such that $\textbf{u}_\beta = (\pmb{\omega}, \pmb{\sigma})$.
In this way the \textit{attacker} NN can influence the generation of the road.

At each instant, the car $c$ have knowledge of its current velocity $v_c$ and, trough some tilt sensors, it can also measure the steepness of the road in its current position $\theta_c = r'(x_c)$, where $x_c$ is the position of the car.
The car can control its acceleration $a_c$ through the actuator that controls the throttle.

Given the setting described above, it is possible to turn the requirement into a STL formula.
Since it must hold for the whole trajectory of the car, we used the $\mathcal{G}$lobally operator.
Let $\tilde{v}$ be the desired steady velocity and $\varepsilon$ be the tolerance on such value.
The STL formula for the requirement $\Phi$ is:
$$ \Phi = \mathcal{G}(v_c \geq \tilde{v} - \varepsilon \; \wedge \; v_c \leq \tilde{v} + \varepsilon) $$

Since the road's steepness is generated only once at the beginning of each \textit{episode}, the only part of the CPS that evolves in time through differential equations is the \textit{agent}'s one.
In particular, the continuous model of the \textit{agent} operates some simplifications:
\begin{itemize}
  \item it is seen as punctiform;
  \item it cannot steer.
\end{itemize}

Let $m$ be the mass of the car (can be disregarded in this case), $g$ be the gravity of $9.81 \frac{m}{s^2}$, $\nu$ be the friction constant of $0.01$.
We call $\left( \frac{dv}{dt} \right)_{in} = a_c$ the controllable acceleration that is provided to the car by the \textit{actuator}.
The car dynamics follows the differential equation:
$$ m \frac{dv}{dt} = m \left( \frac{dv}{dt} \right)_{in} - \nu mg\cos\theta_c   - mg\sin\theta_c$$

The formula above describes how the velocity varies over time.
We can see its dependency on the given acceleration $a_c$, to which we subtract the friction and the vertical component of its weight.

In this case study, the \textit{attacker} is very simple.
It does not take any input depending on the state of $\mathcal{M}$, hence the observable state $\textbf{o}_\beta = \varnothing$.
It gives as output the vector $\textbf{u}_\beta$ to build the function $r(x)$ that represents the profile of the road.
We limited the maximum steepness allowed to the interval $[-25\degree, 25\degree]$ by setting some constraints on $r'(x)$ to prevent trivial adversarial scenarios (vertical walls).

The \textit{defender}, on the other side, takes as input the observable state $\textbf{o}_\alpha = (v_c, \theta_c)$ and gives as output the acceleration $\textbf{u}_\alpha = (a_v)$ of the car $c$.
The simulated model has been limited to allow accelerations in the interval $[-3 \frac{m}{s^2}, 3 \frac{m}{s^2}]$, while the range of allowed velocities is $[-10 \frac{m}{s}, 10 \frac{m}{s}]$.

\section{Car platooning}
We selected the problem of \textit{car platooning} \cite{carplatooning} to test the full potential of our architecture.
This kind of setting is relatively new and it has been developed in the field of \textit{Autonomous Driving}.
The platooning, in fact, is the formation of a line of vehicles in which they follow each other in a controlled way: they should never hit the car in front and they should always have enough space in order to brake on time in case of sudden change of leader's speed.
This case study is starting to gather interest since it promises to reduce the cost of the transport and increase the overall transportation infrastructures' efficiency \cite{platooning_survey}.

Nowadays this problem has been faced with many composite techniques \cite{platooning_survey} to coordinate the actions of the car's pool, most of them rely on the so called \textit{vehicular ad-hoc networks} that can be of the type \textbf{V2V} (Vehicle to Vehicle) or \textbf{V2I} (Vehicle to Infrastructure).

This approach, though, requires specific hardware and a distributed system of coordination that can be an impossible requirement to meet in some cases.
Testing our approach to obtain a robust controller on this kind of problem is interesting, at it explores the possibility of an \textit{individual-basis} decision system.

\subsection{Model}
In the car platooning setting we have $n$ cars that follow each other forming a line.
Following a strategy of \textit{divide et impera}, it is possible to consider just the problem of two cars before generalizing the solution.

In the model $\mathcal{M}$, that we are going to define, we have one leader $l$ and one follower $f$.
Both leader and follower have an internal state that keeps track of the car's position $x$, velocity $v$ and acceleration $a$. 

The requirement $\Phi$ for the problem can be expressed in STL as
$$ \Phi =  \mathcal{G}(d \leq d_{max} \; \wedge \; d \geq d_{min}) $$

where $d = x_l - x_f$ is the distance between $l$ and $f$, and $d_{max}$ and $d_{min}$ are respectively the maximum and minimum distance allowed.
Such distance can be estimated or measured.
In our experiment, we assume that we can measure it by means of a \textit{LIDAR scanner}.
This kind of hardware, that makes use of a laser beam to measure distances, is already installed on some autonomous or semi-autonomous cars.

We used the operator $\mathcal{G}$lobally in the STL formula because we want the property to hold for the whole trajectory of the cars.
The minimum distance allowed was set at $2$ meters and the maximum one at $10$.

Since our aim is to have a safe controller that is able to follow the car ahead under the requirement $\Phi$, it comes natural to label the follower $f$ as the \textit{agent} $\alpha$ of our model $\mathcal{M}$, while all the rest is addressed as $\beta$, the \textit{environment}.
This definition implies that the leader $l$ is considered part of the \textit{environment} too.

Defined the roles inside our abstract model $\mathcal{M}$, we can now analyze how the underlying CPS is configured.
To describe the car's physical behaviour, we need to operate some simplifications:
\begin{itemize}
  \item they are seen as punctiform;
  \item they can move exclusively on a straight line;
  \item they move on a flat landscape;
  \item they can only move forward.
\end{itemize}

Let $\nu$ be the friction coefficient of $0.01$, $g$ be the gravity of $9.81 \frac{m}{s^2}$ and $m$ the mass (that can be disregarded in this case).
The differential equation that describe the car's dynamic is the following:
$$ m \frac{dv}{dt} = m \left( \frac{dv}{dt} \right)_{in}  - \nu mg  $$

The formula above represents the variation of the final velocity of the car with respect to time, given as input the car's acceleration  $\left( \frac{dv}{dt} \right)_{in} = a$ and subtracting the friction due to the movement.

In this specific case study, since both the \textit{agent} and the \textit{environment} are very similar, also their inputs are alike: both are single-element vectors $\textbf{u}_\alpha = (a_f)$ and $\textbf{u}_\beta = (a_l)$ that control the cars' acceleration.
$a_f$ and $a_l$ are respectively the accelerations that the \textit{agent} and the \textit{environment} are going to provide to the dynamic equation illustrated above.
To be more realistic, we limited the acceleration of the car to $[-3 \frac{m}{s^2}, 3 \frac{m}{s^2}]$ and the velocity to $[0 \frac{m}{s}, 20 \frac{m}{s}]$.

In this specific case study, moreover, $\textbf{o}_\alpha \equiv \textbf{o}_\beta$, hence we can refer to the model's state simply as $\textbf{o}$.
This vector contains information about the state of $\mathcal{M}$, in particular $\textbf{o} = (v_l, v_f, d)$, where $v_l$ is leader's velocity, $v_f$ is follower's velocity and $d$ is the relative distance.